using System.Linq;
using Schema.Core.Data;
using Schema.Core.IO;
using static Schema.Core.SchemaResult;
using System.Text;
using Schema.Core.Ext;
using Schema.Core.Schemes;

namespace Schema.Core.Serialization
{
    public class CSharpStorageFormat : IStorageFormat<DataScheme>
    {
        public string Extension => "g.cs";
        public string DisplayName => "CodeGen C#";
        public bool IsImportSupported => false;
        public bool IsExportSupported => true;

        private readonly IFileSystem fileSystem;

        public CSharpStorageFormat(IFileSystem fileSystem)
        {
            this.fileSystem = fileSystem;
        }

        public SchemaResult<DataScheme> DeserializeFromFile(SchemaContext context, string filePath)
        {
            throw new System.NotImplementedException();
        }

        public SchemaResult<DataScheme> Deserialize(SchemaContext context, string content)
        {
            throw new System.NotImplementedException();
        }

        // HACK
        public ManifestEntry ManifestEntry;

        /// <summary>
        /// Determines whether the given ID is a valid C# identifier.
        /// </summary>
        /// <para>
        /// Valid identifiers must follow these rules. The C# compiler produces an error for any identifier that doesn't follow these rules:
        /// Identifiers must start with a letter or underscore (_).
        /// Identifiers can contain Unicode letter characters, decimal digit characters, Unicode connecting characters, Unicode combining characters, or Unicode formatting characters. For more information on Unicode categories, see the Unicode Category Database.
        /// </para>
        /// <param name="id"></param>
        /// <returns></returns>
        /// <see cref="https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/identifier-names"/>
        private static bool IsValidIdentifierName(string id)
        {
            for (int i = 0; i < id.Length; i++)
            {
                if (i == 0)
                {
                    if (!(char.IsLetter(id[i]) || id[i] == '_'))
                    {
                        return false;
                    }
                }
                else
                {
                    if (!(char.IsLetterOrDigit(id[i]) ||  id[i] == '_' || id[i] == '-'))
                    {
                        return false;
                    }
                }
            }

            return true;
        }
        
        public SchemaResult SerializeToFile(SchemaContext context, string filePath, DataScheme scheme)
        {
            var schemeClassName = $"{scheme.SchemeName}Scheme";
            var entryClassName = $"{scheme.SchemeName}Entry";
            var sb = new StringBuilder();

            bool useNamespace = !string.IsNullOrWhiteSpace(ManifestEntry.CSharpNamespace);
            string namespaceHeaderCode = useNamespace
                ? @$"namespace {ManifestEntry.CSharpNamespace} 
{{
"
                : string.Empty;
            string namespaceFooterCode = useNamespace ? "}" : string.Empty;
            
            // Class header
            sb.Append(
$@"using Schema.Core;
using Schema.Core.Data;
using Schema.Core.Schemes;
using UnityEngine;
using static Schema.Core.Schema;

{namespaceHeaderCode}
    /// <summary>
    /// This class was auto-generated by Schema based on the '{scheme.SchemeName}' data scheme.
    /// Do not modify this file directly. Changes may be overwritten.
    /// </summary>
    public partial class {schemeClassName} : SchemeWrapper<{entryClassName}>
    {{
        public const string SCHEMA_NAME = ""{scheme.SchemeName}"";
        
");

            var hasIdAttr = scheme.GetIdentifierAttribute().Try(out var idAttr);
            // ID Entry Enum
            // TODO: Sanitize identifier enums and validate the use-case for this
            if (hasIdAttr)
            {
                sb.Append(
$@"     
        public static class Ids
        {{
");
                foreach (var identifierValue in scheme.GetIdentifierValues())
                {
                    string sanitizedId = identifierValue.ToString()
                        .Replace(' ', '_') // replace whitespace
                        .ToUpper();
                    if (!IsValidIdentifierName(sanitizedId))
                    {
                        return Fail(context, $"Cannot generate identifier for '{sanitizedId}'");
                    }

                    string idValueCode = string.Empty;
                    switch (idAttr.DataType)
                    {
                        case TextDataType _:
                            idValueCode = $"\"{identifierValue}\"";
                            break;
                        case FloatingPointDataType _:
                        case IntegerDataType _:
                            idValueCode = identifierValue.ToString();
                            break;
                    }
                    
                    // TODO: this is only correct if the value is a string...
                    sb.Append(
$@"         
            public const string {sanitizedId} = {idValueCode};
");
                }
                sb.AppendLine(
$@"     
        }}
");
            }

            sb.AppendLine(
@$"     
        public static SchemaResult<{schemeClassName}> Get()
        {{
            if (GetScheme(SCHEMA_NAME).Try(out var scheme, out var error))
            {{
                return SchemaResult<{schemeClassName}>.Pass(new {schemeClassName}(scheme));
            }}
            
            return error.CastError<{schemeClassName}>();
        }}
        
        public static SchemaResult<{entryClassName}> GetEntry(object entryId)
        {{
            if (!Get().Try(out var scheme, out var schemeError))
            {{
                return schemeError.CastError<{entryClassName}>();
            }}
            
            return scheme.GetEntryById(entryId);
        }}

        public {schemeClassName}(DataScheme dataScheme) : base(dataScheme) {{}}

        protected override {entryClassName} EntryFactory(DataScheme dataScheme, DataEntry dataEntry) {{
            return new {entryClassName}(dataScheme, dataEntry);
        }}
    }}

    [SerializeField]
    public partial class {entryClassName} : EntryWrapper
    {{
        public {entryClassName}(DataScheme dataScheme, DataEntry entry) : base(dataScheme, entry) {{}}
");
            foreach (var attributeDefinition in scheme.GetAttributes()
                         .Where(a => a.ShouldPublish))
            {
                // TODO: strip out non-alpha numeric characters
                var attributePropertyName = attributeDefinition.AttributeName
                    .Replace(" ", string.Empty) // remove whitespace
                    .ToPascalCase();

                if (!IsValidIdentifierName(attributePropertyName))
                {
                    return Fail(context, $"Cannot generate identifier for attribute '{attributePropertyName}'");
                }
                var attributeName = attributeDefinition.AttributeName;

                bool codeGenAttributeSetters = scheme.SchemeName == Manifest.MANIFEST_SCHEME_NAME;
                // TODO: Support more GetData functions for new data types
                // Codegen?
                string getDataMethod = "GetDataAsString";
                string csDataType = "string";
                switch (attributeDefinition.DataType)
                {
                    case BooleanDataType _:
                        getDataMethod = "GetDataAsBool";
                        csDataType = "bool";
                        break;
                    case IntegerDataType _:
                        getDataMethod = "GetDataAsInt";
                        csDataType = "int";
                        break;
                    case FloatingPointDataType _:
                        getDataMethod = "GetDataAsFloat";
                        csDataType = "float";
                        break;
                }

                // Add XML doc comment if tooltip exists
                if (!string.IsNullOrWhiteSpace(attributeDefinition.AttributeToolTip))
                {
                    sb.Append(
$@"     
        /// <summary>
        /// {attributeDefinition.AttributeToolTip}
        /// </summary>
");
                }

                if (codeGenAttributeSetters)
                {
                    sb.Append(
$@"     
        public {csDataType} {attributePropertyName}
        {{
            get => DataEntry.{getDataMethod}(""{attributeName}"");
            set => DataScheme.SetDataOnEntry(DataEntry, ""{attributeName}"", value);
        }}
");
                }
                else
                {
                    sb.Append(
$@"     
        public {csDataType} {attributePropertyName} => DataEntry.{getDataMethod}(""{attributeName}"");
");
                }
            }

            sb.Append(
$@" 
    }}
{namespaceFooterCode}
");
            fileSystem.WriteAllText(context, filePath, sb.ToString());
            return Pass($"Wrote {scheme} to file: {filePath}", context);
        }

        public SchemaResult<string> Serialize(DataScheme scheme)
        {
            throw new System.NotImplementedException();
        }
    }
}